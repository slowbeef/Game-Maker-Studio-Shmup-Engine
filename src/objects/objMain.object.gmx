<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>5000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle gamepad axis-"press"ing: Init
//Special thanks to mstop4 on Reddit for posting this solution: https://www.reddit.com/r/gamemaker/comments/3zd1nt/gamepad_analog_stick_pressed/cyls6g1/
//Gamepad controller input
p1HasController = 0;
p2HasController = 0;

lastInputP1GamePad = 0;
lastInputP1GamePadActual = 0;
lastInputP2GamePad = 0;
lastInputP2GamePadActual = 0;

for (var i=0; i&lt;10; i++)
{
    stickLeftPressed[i] = false;
    stickRightPressed[i] = false;
    stickUpPressed[i] = false;
    stickDownPressed[i] = false;

    stickLeftHeld[i] = false;
    stickRightHeld[i] = false;
    stickUpHeld[i] = false;
    stickDownHeld[i] = false;

    stickLeftReleased[i] = false;
    stickRightReleased[i] = false;
    stickUpReleased[i] = false;
    stickDownReleased[i] = false;
}

threshold = 0.8; //Stick sensitvity
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Declare variables and configure controls
// Define global variables

waitTime=300; //Timer for displaying the credits as the game boots up.
            //Recommended to set to approximately 300 for public builds

debugEnabled = false;

deltaTime = 1;      //Whenever paused, this is set to 0, and 1 when unpaused!
                    //Try multiplying things with this to account for pausing state!
mapSwitchTimer=0;
showLoop = 0; //Timer for displaying which loop the player is on (Set on the last event in the levelEvents() script)

loopCounter = 1; //Keeps track of how many game loops we've done (Starts at 1)

currPlayers = 1; //Keeps track of how many players are active in the game (Set by the menuExecute() script)

global.width=512;
global.height=288;

global.currentMap = 0; //Reserved for keeping track of the game's current map
global.prevMap = 0; //Reserved for keeping track of the game's previous map
switchingMaps = false; //Turned off at the very end of loadLevel() script
global.state = states.initialize;
global.statePrevious = global.state; //Reserved variable for storing previous state. Useful for pausing/cutscenes
global.pauseTimer=0;

global.font = font_add_sprite(sprFont, ord('!'), false, 0);
gameEndTimer = 40;
startRoomTimer = 0;
startRoomTimerLength = 140;

threwError = false; //Debug flag for the placeSprites() script
cleaningRoom = false; //Flag to prevent any hiccups when resetting the room
lk = 0; //Reserved for storing the last input the player had (specifically for the konCodeInput() script)

global.tick = 0;            //frame counter, increases every frame in step event
global.playerScore = 0;
global.highScore = 57300;   //Arbitrary number. It's the one GR3 uses, lol
global.highCoScore = 57300;   //Separate the Co-Op score from the single player one
global.playerLives = 2;     //Give the player 3 lives [The last life is 0, not 1]

maxPlayers = 2; //The max number of players the game should have globally. (If you want to add more, you need to add controls for every player and re-work every button-press code to account for the new players, too.)

//Equip menu stuff
typeSelect = true;
shieldSelect = 0;
equipTypePos = 1;
equipShieldPos = 0;
equipChangeTimer = 0;
equipTypeBlinkShow = true;
equipShieldBlinkShow = false;
equipBackTimer = 0;
frModeFlicker = false; //Displays notice about Friendly Mode on equip screen
glFlicker = false; //Displays "Good luck!" on the equip screen
glTimer = 0;        //Timer for above.

//Player 2 Equip Menu Stuff
p2ShieldSelect = 0;
p2EquipTypePos = 1;
p2EquipShieldPos = 0;
p2EquipChangeTimer = 0;
p2EquipTypeBlinkShow = true;
p2EquipShieldBlinkShow = false;
p2EquipBackTimer = 0;
p2MenuProgressedLast = 1;

//Keep track of player's arsenal
missileType = 1;
doubleType = 1;
laserType = 1;
optionType = 1;
shieldType = 1;

//Player 2, too
p2MissileType = 1;
p2DoubleType = 1;
p2LaserType = 1;
p2OptionType = 1;
p2ShieldType = 1;

title = 0;
timer = 0;
fullscreen = false;
resetKey = false;            //Initialization for konCodeInput();




//Parallax night sky
xScroll = 0; //For the bottom-most sky scrolling
//Manually handle the sky background parallax
background_hspeed[0] = -0.2;
background_hspeed[1] = -0.4;
background_hspeed[2] = -0.6;

//As soon as objCamera exists, the above values are added to the below values for parallax offset in relation to objCamera
//This is done to prevent weird graphical hiccups in the middle of map switching, to provide a seamless experience
bg0XParallax = 0;
bg1XParallax = 0;
bg2XParallax = 0;

global.cameraUp = ord('W');
global.cameraDown = ord('S');
global.cameraLeft = ord('A');
global.cameraRight = ord('D');

//Initialize or load game options
if (file_exists("sav"))
{
    ini_open("sav");
    global.bgmVol = real(ini_read_string("Options","bgmVol",75));
    global.sfxVol = real(ini_read_string("Options","sfxVol",75));
    global.grVOptEnabled = real(ini_read_string("Options","grVOptEnabled",false));
    global.frModeEnabled = real(ini_read_string("Options","frModeEnabled",false));
    global.highScore = real(ini_read_string("Game Data","HiScore",57300));
    global.highCoScore = real(ini_read_string("Game Data","HiCoScore",57300));
    windowSize = real(ini_read_string("Options","windowSize",2));
    
    //Player 1 Controls
    global.keyUp = real(ini_read_string("Options","keyUp",vk_up));
    global.keyDown = real(ini_read_string("Options","keyDown",vk_down));
    global.keyLeft = real(ini_read_string("Options","keyLeft",vk_left));
    global.keyRight = real(ini_read_string("Options","keyRight",vk_right));
    global.keyAction1 = real(ini_read_string("Options","keyAction1",ord('Z')));
    global.keyAction2 = real(ini_read_string("Options","keyAction2",ord('X')));
    global.keyAction3 = real(ini_read_string("Options","keyAction3",ord('C')));
    global.keyPause = real(ini_read_string("Options","keyPause",vk_enter));
    
    //Player 2 Controls
    global.keyP2Up = real(ini_read_string("Options","keyP2Up",ord('W')));
    global.keyP2Down = real(ini_read_string("Options","keyP2Down",ord('S')));
    global.keyP2Left = real(ini_read_string("Options","keyP2Left",ord('A')));
    global.keyP2Right = real(ini_read_string("Options","keyP2Right",ord('D')));
    global.keyP2Action1 = real(ini_read_string("Options","keyP2Action1",ord('J')));
    global.keyP2Action2 = real(ini_read_string("Options","keyP2Action2",ord('K')));
    global.keyP2Action3 = real(ini_read_string("Options","keyP2Action3",ord('L')));
    global.keyP2Pause = real(ini_read_string("Options","keyP2Pause",ord('H')));

    ini_close();
}
else
{
    global.bgmVol = 75;
    global.sfxVol = 75;
    global.keyUp = vk_up;
    global.keyDown = vk_down;
    global.keyLeft = vk_left;
    global.keyRight = vk_right;
    global.keyAction1 = ord('Z');
    global.keyAction2 = ord('X');
    global.keyAction3 = ord('C');
    global.keyPause = vk_enter;
    
    global.keyP2Up = ord('W');
    global.keyP2Down = ord('S');
    global.keyP2Left = ord('A')
    global.keyP2Right = ord('D')
    global.keyP2Action1 = ord('J')
    global.keyP2Action2 = ord('K')
    global.keyP2Action3 = ord('L');
    global.keyP2Pause = ord('H');
    
    global.grVOptEnabled = false;
    global.frModeEnabled = false;
    windowSize = 2;
    ini_open("sav");
    ini_write_string("Options","bgmVol",string(75));
    ini_write_string("Options","sfxVol",string(75));
    ini_write_string("Options","grVOptEnabled",string(false));
    ini_write_string("Options","windowSize",string(2));
    
    //Player 1 Controls
    ini_write_string("Options","keyUp",string(vk_up));
    ini_write_string("Options","keyDown",string(vk_down));
    ini_write_string("Options","keyLeft",string(vk_left));
    ini_write_string("Options","keyRight",string(vk_right));
    ini_write_string("Options","keyAction1",string(ord('Z')));
    ini_write_string("Options","keyAction2",string(ord('X')));
    ini_write_string("Options","keyAction3",string(ord('C')));
    ini_write_string("Options","keyPause",string(vk_enter));
    
    //Player 2 Controls
    ini_write_string("Options","keyP2Up",string(ord('W')));
    ini_write_string("Options","keyP2Down",string(ord('S')));
    ini_write_string("Options","keyP2Left",string(ord('A')));
    ini_write_string("Options","keyP2Right",string(ord('D')));
    ini_write_string("Options","keyP2Action1",string(ord('J')));
    ini_write_string("Options","keyP2Action2",string(ord('K')));
    ini_write_string("Options","keyP2Action3",string(ord('L')));
    ini_write_string("Options","keyP2Pause",string(ord('H')));
    
    ini_close();
}

window_set_size(global.width*windowSize,global.height*windowSize);

//Initialize sounds
global.currentSong=0;       
rememberBGM = true; //Flag to remember which song was last played
global.prevSong=0; //Song to remember, if the previous was true.
bgmFadeoutMultiplier = 1; //To handle song fadeout
songStream = 0;  //Keeps track of how far into the song we are (for looping in handleBGM();)

audio_group_load(sfxMenu);
audio_sound_gain(global.currentSong, (global.bgmVol/100), 0);
audio_group_set_gain(sfxMenu, (global.sfxVol/100), 0);
audio_group_set_gain(sfxInGame, (global.sfxVol/100), 0);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Declare tiletype constants
//Assume every piece of the array represents a 16x16 tile
/*
List:
    blank,
    solid,
*/

//Below is Row 1


/* 
Slowbeef:

I don't really love this because it locks you to 16x16 tilesets. It might be better in general to keep tilesets to that
limit for a reason I'm not sure of, though.

At any rate, attempting a different method.
*/

/*getTileType(tileNumber) {
    if (tileNumber == 4) { return "solid"; }
    if (tileNumber == 5) { return "solid"; }
    if (tileNumber == 6) { return "solid"; }
    if (tileNumber &gt; 512) { return "solid"; }
    
    return "blank";    
}

tiletypes[0] = "blank";
tiletypes[1] = "blank";
tiletypes[2] = "blank";
tiletypes[3] = "blank";
tiletypes[4] = "solid";
tiletypes[5] = "solid";
tiletypes[6] = "solid";
tiletypes[7] = "blank";
tiletypes[8] = "blank";
tiletypes[9] = "blank";
tiletypes[10] = "blank";
tiletypes[11] = "blank";
tiletypes[12] = "blank";
tiletypes[13] = "blank";
tiletypes[14] = "blank";
tiletypes[15] = "blank";
//below is Row 2
tiletypes[16] = "blank";
tiletypes[17] = "blank";
tiletypes[18] = "blank";
tiletypes[19] = "blank";
tiletypes[20] = "solid";
tiletypes[21] = "solid";
tiletypes[22] = "solid";
tiletypes[23] = "solid";
tiletypes[24] = "solid";
tiletypes[25] = "blank";
tiletypes[26] = "blank";
tiletypes[27] = "blank";
tiletypes[28] = "blank";
tiletypes[29] = "blank";
tiletypes[30] = "blank";
tiletypes[31] = "blank";
//Below is Row 3
tiletypes[32] = "blank";
tiletypes[33] = "blank";
tiletypes[34] = "blank";
tiletypes[35] = "blank";
tiletypes[36] = "blank";
tiletypes[37] = "blank";
tiletypes[38] = "blank";
tiletypes[39] = "blank";
tiletypes[40] = "blank";
tiletypes[41] = "blank";
tiletypes[42] = "blank";
tiletypes[43] = "blank";
tiletypes[44] = "blank";
tiletypes[45] = "blank";
tiletypes[46] = "blank";
tiletypes[47] = "blank";
//Below is Row 4
tiletypes[48] = "blank";
tiletypes[49] = "sign";
tiletypes[50] = "blank";
tiletypes[51] = "blank";
tiletypes[52] = "blank";
tiletypes[53] = "blank";
tiletypes[54] = "blank";
tiletypes[55] = "blank";
tiletypes[56] = "blank";
tiletypes[57] = "blank";
tiletypes[58] = "blank";
tiletypes[59] = "blank";
tiletypes[60] = "blank";
tiletypes[61] = "blank";
tiletypes[62] = "blank";
tiletypes[63] = "blank";
//Below is Row 5
tiletypes[64] = "blank";
tiletypes[65] = "blank";
tiletypes[66] = "blank";
tiletypes[67] = "blank";
tiletypes[68] = "blank";
tiletypes[69] = "blank";
tiletypes[70] = "blank";
tiletypes[71] = "blank";
tiletypes[72] = "blank";
tiletypes[73] = "blank";
tiletypes[74] = "blank";
tiletypes[75] = "blank";
tiletypes[76] = "blank";
tiletypes[77] = "blank";
tiletypes[78] = "blank";
tiletypes[79] = "blank";
//Below is Row 6
tiletypes[80] = "blank";
tiletypes[81] = "blank";
tiletypes[82] = "blank";
tiletypes[83] = "blank";
tiletypes[84] = "blank";
tiletypes[85] = "blank";
tiletypes[86] = "blank";
tiletypes[87] = "blank";
tiletypes[88] = "blank";
tiletypes[89] = "blank";
tiletypes[90] = "blank";
tiletypes[91] = "blank";
tiletypes[92] = "blank";
tiletypes[93] = "blank";
tiletypes[94] = "blank";
tiletypes[95] = "blank";
//Below is Row 7
tiletypes[96] = "blank";
tiletypes[97] = "blank";
tiletypes[98] = "blank";
tiletypes[99] = "blank";
tiletypes[100] = "blank";
tiletypes[101] = "blank";
tiletypes[102] = "solid";
tiletypes[103] = "solid";
tiletypes[104] = "solid";
tiletypes[105] = "solid";
tiletypes[106] = "solid";
tiletypes[107] = "solid";
tiletypes[108] = "blank";
tiletypes[109] = "blank";
tiletypes[110] = "blank";
tiletypes[111] = "blank";
//Below is Row 8
tiletypes[112] = "blank";
tiletypes[113] = "blank";
tiletypes[114] = "blank";
tiletypes[115] = "blank";
tiletypes[116] = "blank";
tiletypes[117] = "solid";
tiletypes[118] = "solid";
tiletypes[119] = "solid";
tiletypes[120] = "solid";
tiletypes[121] = "solid";
tiletypes[122] = "solid";
tiletypes[123] = "blank";
tiletypes[124] = "blank";
tiletypes[125] = "blank";
tiletypes[126] = "blank";
tiletypes[127] = "blank";
//Below is Row 9
tiletypes[128] = "blank";
tiletypes[129] = "blank";
tiletypes[130] = "blank";
tiletypes[131] = "blank";
tiletypes[132] = "blank";
tiletypes[133] = "blank";
tiletypes[134] = "blank";
tiletypes[135] = "blank";
tiletypes[136] = "blank";
tiletypes[137] = "blank";
tiletypes[138] = "blank";
tiletypes[139] = "blank";
tiletypes[140] = "blank";
tiletypes[141] = "blank";
tiletypes[142] = "blank";
tiletypes[143] = "blank";
//Below is Row 10
tiletypes[144] = "blank";
tiletypes[145] = "blank";
tiletypes[146] = "blank";
tiletypes[147] = "blank";
tiletypes[148] = "blank";
tiletypes[149] = "blank";
tiletypes[150] = "blank";
tiletypes[151] = "blank";
tiletypes[152] = "blank";
tiletypes[153] = "blank";
tiletypes[154] = "blank";
tiletypes[155] = "blank";
tiletypes[156] = "blank";
tiletypes[157] = "blank";
tiletypes[158] = "blank";
tiletypes[159] = "blank";
//Below is Row 11
tiletypes[160] = "blank";
tiletypes[161] = "blank";
tiletypes[162] = "blank";
tiletypes[163] = "blank";
tiletypes[164] = "blank";
tiletypes[165] = "blank";
tiletypes[166] = "blank";
tiletypes[167] = "blank";
tiletypes[168] = "blank";
tiletypes[169] = "blank";
tiletypes[170] = "blank";
tiletypes[171] = "blank";
tiletypes[172] = "blank";
tiletypes[173] = "blank";
tiletypes[174] = "blank";
tiletypes[175] = "blank";
//Below is Row 12
tiletypes[176] = "blank";
tiletypes[177] = "blank";
tiletypes[178] = "blank";
tiletypes[179] = "blank";
tiletypes[180] = "blank";
tiletypes[181] = "blank";
tiletypes[182] = "blank";
tiletypes[183] = "blank";
tiletypes[184] = "blank";
tiletypes[185] = "blank";
tiletypes[186] = "blank";
tiletypes[187] = "blank";
tiletypes[188] = "blank";
tiletypes[189] = "blank";
tiletypes[190] = "blank";
tiletypes[191] = "blank";
//Below is Row 13
tiletypes[192] = "blank";
tiletypes[193] = "blank";
tiletypes[194] = "blank";
tiletypes[195] = "blank";
tiletypes[196] = "blank";
tiletypes[197] = "blank";
tiletypes[198] = "blank";
tiletypes[199] = "blank";
tiletypes[200] = "blank";
tiletypes[201] = "blank";
tiletypes[202] = "blank";
tiletypes[203] = "blank";
tiletypes[204] = "blank";
tiletypes[205] = "blank";
tiletypes[206] = "blank";
tiletypes[207] = "blank";
//Below is Row 14
tiletypes[208] = "blank";
tiletypes[209] = "blank";
tiletypes[210] = "solid";
tiletypes[211] = "solid";
tiletypes[212] = "solid";
tiletypes[213] = "blank";
tiletypes[214] = "blank";
tiletypes[215] = "blank";
tiletypes[216] = "blank";
tiletypes[217] = "blank";
tiletypes[218] = "blank";
tiletypes[219] = "blank";
tiletypes[220] = "blank";
tiletypes[221] = "blank";
tiletypes[222] = "blank";
tiletypes[223] = "blank";
//Below is Row 15
tiletypes[224] = "blank";
tiletypes[225] = "blank";
tiletypes[226] = "blank";
tiletypes[227] = "blank";
tiletypes[228] = "blank";
tiletypes[229] = "blank";
tiletypes[230] = "blank";
tiletypes[231] = "blank";
tiletypes[232] = "blank";
tiletypes[233] = "blank";
tiletypes[234] = "blank";
tiletypes[235] = "blank";
tiletypes[236] = "blank";
tiletypes[237] = "blank";
tiletypes[238] = "blank";
tiletypes[239] = "blank";
//Below is Row 16
tiletypes[240] = "blank";
tiletypes[241] = "blank";
tiletypes[242] = "blank";
tiletypes[243] = "blank";
tiletypes[244] = "blank";
tiletypes[245] = "blank";
tiletypes[246] = "blank";
tiletypes[247] = "blank";
tiletypes[248] = "blank";
tiletypes[249] = "blank";
tiletypes[250] = "blank";
tiletypes[251] = "blank";
tiletypes[252] = "blank";
tiletypes[253] = "blank";
tiletypes[254] = "blank";
tiletypes[255] = "blank";
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset pressed and released states (Game Controllers)
for (var i=0; i&lt;10; i++)
{
    stickLeftPressed[i] = false;
    stickRightPressed[i] = false;
    stickUpPressed[i] = false;
    stickDownPressed[i] = false;

    stickLeftReleased[i] = false;
    stickRightReleased[i] = false;
    stickUpReleased[i] = false;
    stickDownReleased[i] = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for changes in axis state
for (var i=0; i&lt;10; i++)
{
    // left pressed
    if (!stickLeftHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislh) &lt;= -threshold)
    {
        stickLeftHeld[i] = true;
        stickLeftPressed[i] = true;
        stickLeftReleased[i] = false;
        alarm[0] = 1;
    }

    // left released
    else if (stickLeftHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislh) &gt; -threshold)
    {
        stickLeftHeld[i] = false;
        stickLeftPressed[i] = false;
        stickLeftReleased[i] = true;
        alarm[0] = 1;
    }


    // right pressed
    if (!stickRightHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislh) &gt;= threshold)
    {
        stickRightHeld[i] = true;
        stickRightPressed[i] = true;
        stickRightReleased[i] = false;
        alarm[0] = 1;
    }

    // right released
    else if (stickRightHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislh) &lt; threshold)
    {
        stickRightHeld[i] = false;
        stickRightPressed[i] = false;
        stickRightReleased[i] = true;
        alarm[0] = 1;
    }


    // up pressed
    if (!stickUpHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislv) &lt;= -threshold)
    {
        stickUpHeld[i] = true;
        stickUpPressed[i] = true;
        stickUpReleased[i] = false;
        alarm[0] = 1;
    }

    // up released
    else if (stickUpHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislv) &gt; -threshold)
    {
        stickUpHeld[i] = false;
        stickUpPressed[i] = false;
        stickUpReleased[i] = true;
        alarm[0] = 1;
    }


    // down pressed
    if (!stickDownHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislv) &gt;= threshold)
    {
        stickDownHeld[i] = true;
        stickDownPressed[i] = true;
        stickDownReleased[i] = false;
        alarm[0] = 1;
    }

    // down released
    else if (stickDownHeld[i] &amp;&amp; gamepad_axis_value(i,gp_axislv) &lt; threshold)
    {
        stickDownHeld[i] = false;
        stickDownPressed[i] = false;
        stickDownReleased[i] = true;
        alarm[0] = 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle game states and window re-sizing
switch(global.state) //Game mode handling
{
    case states.initialize: // initial state
        //Turn off the night sky (in case we were to reset the game)
        background_visible[0] = false;
        background_visible[1] = false;
        background_visible[2] = false;
        if global.tick==1{audio_play_sound(itsjoke,1,false);}
        if global.tick&gt;=waitTime+30
        
        {global.state=1; instance_create(190,80,objTitle);} //changeBGM(bgmTitle,true);
        levelData = 0;
        levelDataLayer2 = 0;
        levelDataSprites = 0;
        extFiles=false;
        break;
    case states.titleScreen: // title
        //Turn on the night sky
        background_visible[0] = true;
        background_visible[1] = true;
        background_visible[2] = true;
            break;
    case states.gameMode: // game mode
    case states.cutscene: // cutscene mode
        handleBGM();
        //Only trigger Game Over if both players are dead (If there's only one player, just do it)
        if (global.playerLives&lt;0)
        {
            if instance_exists(objPlayer2)
            {
                if (objPlayer2.dead &amp;&amp; objPlayer1.dead)
                {
                    handleGameOver();
                }
            }
            else
            {
                handleGameOver();
            }
        }
        //Handle pausing
        if ((objMain.keyP1PausePressed || objMain.keyP2PausePressed) &amp;&amp; global.pauseTimer&lt;=0)
        {
            if instance_exists(objPlayer)
            {
                if (!objPlayer.dead)
                {
                deltaTime = 0;
                //Only allow pausing if we haven't died
                audio_pause_sound(global.currentSong);
                global.statePrevious=global.state;
                global.state=5;
                global.pauseTimer=10;
                
                //Freeze the parallax night sky
                background_hspeed[0] = 0;
                background_hspeed[1] = 0;
                background_hspeed[2] = 0;
                }
            }
        }
        break;
    case states.startRoom: // START screen
        handleBGM();
        if startRoomTimer&gt;0{startRoomTimer--;}
        if startRoomTimer&lt;=0
        {
            global.state = states.gameMode;
            //Handle friendly mode
            if (global.frModeEnabled)
            {
                objMain.shieldType=1; //Just in case this slipped past us, enforce that [?] is Force Field
                objPlayer.HP = 11;
                objPlayer.HPMax = 11; //Used for objCamera so it can properly scale Force Field when drawn to the screen
                objPlayer.hasQuestion = true;
                audio_stop_sound(sfxMenuAccept);
                audio_play_sound(sfxMenuAccept,0,false);
            }
        }
        break;
    case states.paused: // paused
        //Handle Unpausing
        konCodeInput(); //huhuh
        if ((objMain.keyP1PausePressed || objMain.keyP2PausePressed) &amp;&amp; !keyboard_check(vk_alt) &amp;&amp; global.pauseTimer&lt;=0) {
            deltaTime = 1;
            audio_resume_sound(global.currentSong);
            global.state=global.statePrevious;
            global.statePrevious=5;
            global.pauseTimer=10;     
            //Unfreeze the parallax night sky
            background_hspeed[0] = -0.2;
            background_hspeed[1] = -0.4;
            background_hspeed[2] = -0.6;
        }
        break;
    case states.gameOver: // game over
        break;
    default: // edge case; do nothing
        break;
}

if (global.pauseTimer&gt;0) {
    global.pauseTimer--;
}

if (keyboard_check(vk_escape)) {
    if instance_exists(objTitle) {
        if objTitle.currentMenu==0 {
            gameEndTimer--;
            if gameEndTimer&lt;=0 {
                game_end();
            }
        }
    } else {
    
        gameEndTimer--;
        if gameEndTimer&lt;=0
            {
            game_end();
            }
        }
    }
else{gameEndTimer=40;}


if (timer &lt;= 0)
        {
            if (keyboard_check_pressed(ord('2')) &amp;&amp; windowSize!=2)
            {
                windowSize = 2;
                window_set_size(global.width*windowSize,global.height*windowSize);
                timer = 10;
            }
            else if (keyboard_check_pressed(ord('1')) &amp;&amp; windowSize!=1)
            {
                windowSize = 1;
                window_set_size(global.width*windowSize,global.height*windowSize);
                timer = 10;
            }
            else if (keyboard_check_pressed(ord('3')) &amp;&amp; windowSize!=3)
            {
                windowSize = 3;
                window_set_size(global.width*windowSize,global.height*windowSize);
                timer = 10;
            }
            else if (keyboard_check(vk_alt)&amp;&amp;keyboard_check_pressed(vk_enter))
            {
                fullscreen = !fullscreen;
                window_set_fullscreen(fullscreen);
                timer = 10;
            }
        }
        else
        {
            timer--;
        }

//Keep track of how long the game has been running for
global.tick++;
if (mapSwitchTimer&gt;0){mapSwitchTimer-=deltaTime;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle highscore

if (currPlayers&lt;=1)
{
    if (global.playerScore &gt; global.highScore)
    {global.highScore = global.playerScore}
}
else
{
    if (global.playerScore &gt; global.highCoScore)
    {global.highCoScore = global.playerScore}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle the item equip screen
if (global.state==states.equipScreen)
{
    if !audio_is_playing(musItemEquip)
    {
        changeBGM(musItemEquip,true);
    }
    
    //Get input
    var keyLeft = -keyP1LeftPressed;
    var keyRight = keyP1RightPressed;
    var moveX = keyLeft+keyRight;
    var keyUp = -keyP1UpPressed;
    var keyDown = keyP1DownPressed;
    var moveY = keyUp+keyDown;
    
    var p2KeyLeft = -keyP2LeftPressed;
    var p2KeyRight = keyP2RightPressed;
    var p2MoveX = p2KeyLeft+p2KeyRight;
    var p2KeyUp = -keyP2UpPressed;
    var p2KeyDown = keyP2DownPressed;
    var p2MoveY = p2KeyUp+p2KeyDown;
    
    var gameStart = false;
    
    //Adds a delay between button presses, but also controls the green rectangles blinking in the Draw Event    
    if equipChangeTimer&gt;1{equipChangeTimer--;}
    if equipBackTimer&gt;1{equipBackTimer--;}
    if p2EquipChangeTimer&gt;1{p2EquipChangeTimer--;}
    if p2EquipBackTimer&gt;1{p2EquipBackTimer--;}

    //Wrap around the menu if we go out of bounds
    if (equipChangeTimer==1 || equipBackTimer==1)
    {
        if (menuProgressedLast==1){shieldSelect++;}
        if (menuProgressedLast==2)
        {
            if (!global.frModeEnabled)
            {
                shieldSelect--;
            }
            else
            {
                shieldSelect-=2;
            }
        }
        menuProgressedLast = 0;
        equipChangeTimer=0;
        equipBackTimer=0;
    }
    if (p2EquipChangeTimer==1 || p2EquipBackTimer==1)
    {
        if (p2MenuProgressedLast==1){p2ShieldSelect++;}
        if (p2MenuProgressedLast==2)
        {
            if (!global.frModeEnabled)
            {
                p2ShieldSelect--;
            }
            else
            {
                p2ShieldSelect-=2;
            }
        }
        p2MenuProgressedLast = 0;
        p2EquipChangeTimer=0;
        p2EquipBackTimer=0;
    }
    
    //Move around the menu if we press Confirm/Start, but add a delay between presses.
    if ((keyP1Action2Pressed || keyP1PausePressed) &amp;&amp; equipChangeTimer&lt;=0 &amp;&amp; equipBackTimer&lt;=0 &amp;&amp; shieldSelect&lt;2)
    {
        audio_stop_sound(sfxMenuAccept);
        audio_stop_sound(sfxMenuCancel);
        audio_play_sound(sfxMenuAccept,0,false);
        equipChangeTimer=50;
        menuProgressedLast=1;
    }
    if (((keyP2Action2Pressed || keyP2PausePressed) &amp;&amp; p2EquipChangeTimer&lt;=0 &amp;&amp; p2EquipBackTimer&lt;=0 &amp;&amp; p2ShieldSelect&lt;2) &amp;&amp; objMain.currPlayers &gt;1)
    {
        audio_stop_sound(sfxMenuAccept);
        audio_stop_sound(sfxMenuCancel);
        audio_play_sound(sfxMenuAccept,0,false);
        p2EquipChangeTimer=50;
        p2MenuProgressedLast=1;
    }
    
    //Move around the menu if we press Cancel, but add a delay between presses.
    if (keyP1Action1Pressed &amp;&amp; shieldSelect&gt;0 &amp;&amp; equipBackTimer&lt;=0 &amp;&amp; equipChangeTimer&lt;=0)
    {
        if ((p2ShieldSelect&lt;=1 &amp;&amp; objMain.currPlayers&gt;1)  || (objMain.currPlayers&lt;=1 &amp;&amp; shieldSelect&lt;=1)) //Only allow menu cancelling if Player 2 isn't finished with weapon configuration, or if we're on single player and just finished weapon configuration.
        {
            audio_stop_sound(sfxMenuCancel);
            audio_play_sound(sfxMenuCancel,0,false);
            equipBackTimer=15;
            menuProgressedLast=2;
        }
    }
    if ((keyP2Action1Pressed &amp;&amp; p2ShieldSelect&gt;0 &amp;&amp; p2EquipBackTimer&lt;=0 &amp;&amp; p2EquipChangeTimer&lt;=0) &amp;&amp; objMain.currPlayers&gt;1 &amp;&amp; (p2ShieldSelect&lt;=1 || shieldSelect&lt;=1))
    {
        audio_stop_sound(sfxMenuCancel);
        audio_play_sound(sfxMenuCancel,0,false);
        p2EquipBackTimer=15;
        p2MenuProgressedLast=2;
    }
    
    if (typeSelect)
    {
    
        //Handle player 1
        if (shieldSelect==0)
        {
            if (equipChangeTimer&lt;=0)
            {
                if (moveY==1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); equipTypePos++;}
                if (moveY==-1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); equipTypePos--;}
            }
            
            if (equipTypePos&lt;1){equipTypePos=4;}
            if (equipTypePos&gt;4){equipTypePos=1;}
        
            switch(equipTypePos)
            {
                case 1:
                    missileType = 1;
                    doubleType = 1;
                    laserType = 1;
                    optionType = 1;
                    break;
                case 2:
                    missileType = 2;    // 2-way
                    doubleType = 2;     // Tail gun
                    laserType = 2;      // Ripple
                    optionType = 2;     // Option
                    break;
                case 3:
                    missileType = 3;    // Spread Bomb
                    doubleType = 3;     // Vertical
                    laserType = 3;      // C.Laser
                    optionType = 3;     // Option
                    break;
                case 4:
                    missileType = 4;    // Photon Torpedo
                    doubleType = 4;     // Back Double
                    laserType = 4;      // Twin Laser
                    optionType = 4;     // Option
                    break;
                default:
                    break;
            }
        }
        if (shieldSelect==1)
        {
            //Autopilot into Force Field if we have Friendly Mode enabled
            if (global.frModeEnabled)
            {
                if (equipChangeTimer&lt;=0)
                {
                    menuProgressedLast=1;
                    equipShieldPos = 1;
                    shieldType = 1;
                    audio_stop_sound(sfxMenuAccept);
                    audio_stop_sound(sfxMenuCancel);
                    audio_play_sound(sfxMenuAccept,0,false);
                    equipChangeTimer=50;
                }
            }
            else
            {
                if (equipChangeTimer&lt;=0)
                {
                    if (moveX==1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); equipShieldPos++;}
                    if (moveX==-1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); equipShieldPos--;}
                }
                //Wrap around
                if (equipShieldPos&gt;1) {equipShieldPos = 0;}
                if (equipShieldPos&lt;0) {equipShieldPos = 1;}
                
                //Finally, assign the shield type
                if (equipShieldPos==0){shieldType = 0;} //Shield
                if (equipShieldPos==1){shieldType = 1;} //Force Field
            }
        }
            
        //Handle player 2
        if (p2ShieldSelect==0 &amp;&amp; objMain.currPlayers &gt;1)
        {
            if (p2EquipChangeTimer&lt;=0)
            {
                if (p2MoveY==1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); p2EquipTypePos++;}
                if (p2MoveY==-1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); p2EquipTypePos--;}
            }
            
            if (p2EquipTypePos&lt;1){p2EquipTypePos=4;}
            if (p2EquipTypePos&gt;4){p2EquipTypePos=1;}
        
            switch(p2EquipTypePos)
            {
                case 1:
                    p2MissileType = 1;
                    p2DoubleType = 1;
                    p2LaserType = 1;
                    p2OptionType = 1;
                    break;
                case 2:
                    p2MissileType = 2;    // 2-way
                    p2DoubleType = 2;     // Tail gun
                    p2LaserType = 2;      // Ripple
                    p2OptionType = 2;     // Option
                    break;
                case 3:
                    p2MissileType = 3;    // Spread Bomb
                    p2DoubleType = 3;     // Vertical
                    p2LaserType = 3;      // C.Laser
                    p2OptionType = 3;     // Option
                    break;
                case 4:
                    p2MissileType = 4;    // Photon Torpedo
                    p2DoubleType = 4;     // Back Double
                    p2LaserType = 4;      // Twin Laser
                    p2OptionType = 4;     // Option
                    break;
                default:
                    break;
            }
        }
        if (p2ShieldSelect==1 &amp;&amp; objMain.currPlayers &gt;1)
        {
            //Autopilot into Force Field if we have Friendly Mode enabled
            if (global.frModeEnabled)
            {
                if (p2EquipChangeTimer&lt;=0)
                {
                    p2MenuProgressedLast=1;
                    p2EquipShieldPos = 1;
                    p2ShieldType = 1;
                    audio_stop_sound(sfxMenuAccept);
                    audio_stop_sound(sfxMenuCancel);
                    audio_play_sound(sfxMenuAccept,0,false);
                    p2EquipChangeTimer=50;
                }
            }
            else
            {
                if (p2EquipChangeTimer&lt;=0)
                {
                    if (p2MoveX==1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); p2EquipShieldPos++;}
                    if (p2MoveX==-1) {audio_stop_sound(sfxMenuTweak); audio_play_sound(sfxMenuTweak,0,false); p2EquipShieldPos--;}
                }
                //Wrap around
                if (p2EquipShieldPos&gt;1) {p2EquipShieldPos = 0;}
                if (p2EquipShieldPos&lt;0) {p2EquipShieldPos = 1;}
                
                //Finally, assign the shield type
                if (p2EquipShieldPos==0){p2ShieldType = 0;} //Shield
                if (p2EquipShieldPos==1){p2ShieldType = 1;} //Force Field
            }
        }
    }
    
    
    //If we've hit the end of the menu, start the game
    if (typeSelect &amp;&amp; shieldSelect&gt;1 &amp;&amp; equipChangeTimer&lt;=0)
    {
        if (objMain.currPlayers&lt;=1)
        {
            if (glTimer&lt;=0){glTimer=75;}
        }
        else
        {
            if (shieldSelect&gt;1 &amp;&amp; equipChangeTimer&lt;=0) &amp;&amp; (p2ShieldSelect&gt;1 &amp;&amp; p2EquipChangeTimer&lt;=0) //Wait for both players
            {
                if (glTimer&lt;=0){glTimer=75;}
            }
        }
        
        if (glTimer==1){gameStart=true;}
    }
    
    if (gameStart)
    {
        //Friendly Mode is taken care of in the gamestates script in the Step Event of objMain
        instance_create(-256,0,objCamera);
        player1 = instance_create(objCamera.x+128-64,128,objPlayer1);
        var thisHitbox = instance_create(objPlayer.x,objPlayer.y,objPlayerCapsuleHitbox);
        thisHitbox.myPlayer = player1.id;
        if (objMain.currPlayers&gt;1)
        {
            player2 = instance_create(objCamera.x+128-64,128+32,objPlayer2);
            player1.y = 128-32;
            thisHitbox2 = instance_create(objPlayer2.x,objPlayer2.y,objPlayerCapsuleHitbox);
            thisHitbox2.myPlayer = player2.id;
        }
        audio_group_unload(sfxMenu);
        audio_group_load(sfxInGame);
        loadLevel("volcano.oel");
        global.prevMap = "volcano.oel";
        audio_stop_sound(global.currentSong);
        changeBGM(musFlight2,false);
        objMain.x = objCamera.x;
        objMain.y = objCamera.y;
        global.state = states.startRoom;
        objMain.startRoomTimer = objMain.startRoomTimerLength;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for global controller inputs
controller1 = 0;
if p1HasController&gt;0
{
    controller1 = p1HasController;
}

controller2 = 0;
if p2HasController&gt;0
{
    controller2 = p2HasController;
}

keyP1Up = max(keyboard_check(global.keyUp) &amp;&amp; global.keyUp != -1,gamepad_button_check(controller1,global.keyUp) &amp;&amp; global.keyUp != -1,stickUpHeld[controller1]);
keyP1UpPressed = (keyboard_check_pressed(global.keyUp) &amp;&amp; global.keyUp != -1) || stickUpPressed[controller1];
keyP1Down = max(keyboard_check(global.keyDown) &amp;&amp; global.keyDown != -1,gamepad_button_check(controller1,global.keyDown) &amp;&amp; global.keyDown != -1,stickDownHeld[controller1]);
keyP1DownPressed = (keyboard_check_pressed(global.keyDown) &amp;&amp; global.keyDown != -1) || stickDownPressed[controller1];
keyP1Left = max(keyboard_check(global.keyLeft) &amp;&amp; global.keyLeft != -1,gamepad_button_check(controller1,global.keyLeft) &amp;&amp; global.keyLeft != -1,stickLeftHeld[controller1]);
keyP1LeftPressed = (keyboard_check_pressed(global.keyLeft) &amp;&amp; global.keyLeft != -1) || stickLeftPressed[controller1];
keyP1Right = max(keyboard_check(global.keyRight) &amp;&amp; global.keyRight != -1,gamepad_button_check(controller1,global.keyRight) &amp;&amp; global.keyRight != -1,stickRightHeld[controller1]);
keyP1RightPressed = (keyboard_check_pressed(global.keyRight) &amp;&amp; global.keyRight != -1) || stickRightPressed[controller1];
keyP1Action1 = max(keyboard_check(global.keyAction1) &amp;&amp; global.keyAction1 != -1,gamepad_button_check(controller1,global.keyAction1));
keyP1Action1Pressed = max(keyboard_check_pressed(global.keyAction1) &amp;&amp; global.keyAction1 != -1,gamepad_button_check(controller1,global.keyAction1));
keyP1Action2 = max(keyboard_check(global.keyAction2) &amp;&amp; global.keyAction2 != -1,gamepad_button_check(controller1,global.keyAction2));
keyP1Action2Pressed = max(keyboard_check_pressed(global.keyAction2) &amp;&amp; global.keyAction2 != -1,gamepad_button_check(controller1,global.keyAction2));
keyP1Action3 = max(keyboard_check(global.keyAction3) &amp;&amp; global.keyAction3 != -1,gamepad_button_check(controller1,global.keyAction3));
keyP1Action3Pressed = max(keyboard_check_pressed(global.keyAction3) &amp;&amp; global.keyAction3 != -1,gamepad_button_check(controller1,global.keyAction3));
keyP1Pause = max(keyboard_check(global.keyPause) &amp;&amp; global.keyPause != -1,gamepad_button_check(controller1,global.keyPause));
keyP1PausePressed = max(keyboard_check_pressed(global.keyPause) &amp;&amp; global.keyPause != -1,gamepad_button_check(controller1,global.keyPause));

keyP2Up = max(keyboard_check(global.keyP2Up) &amp;&amp; global.keyP2Up != -1,gamepad_button_check(controller2,global.keyP2Up) &amp;&amp; global.keyP2Up != -1,stickUpHeld[controller2]);
keyP2UpPressed = (keyboard_check_pressed(global.keyP2Up) &amp;&amp; global.keyP2Up != -1) || stickUpPressed[controller2];
keyP2Down = max(keyboard_check(global.keyP2Down) &amp;&amp; global.keyP2Down != -1,gamepad_button_check(controller2,global.keyP2Down) &amp;&amp; global.keyP2Down != -1,stickDownHeld[controller2]);
keyP2DownPressed = (keyboard_check_pressed(global.keyP2Down) &amp;&amp; global.keyP2Down != -1) || stickDownPressed[controller2];
keyP2Left = max(keyboard_check(global.keyP2Left) &amp;&amp; global.keyP2Left != -1,gamepad_button_check(controller2,global.keyP2Left) &amp;&amp; global.keyP2Left != -1,stickLeftHeld[controller2]);
keyP2LeftPressed = (keyboard_check_pressed(global.keyP2Left) &amp;&amp; global.keyP2Left != -1) || stickLeftPressed[controller2];
keyP2Right = max(keyboard_check(global.keyP2Right) &amp;&amp; global.keyP2Right != -1,gamepad_button_check(controller2,global.keyP2Right) &amp;&amp; global.keyP2Right != -1,stickRightHeld[controller2]);
keyP2RightPressed = (keyboard_check_pressed(global.keyP2Right) &amp;&amp; global.keyP2Right != -1) || stickRightPressed[controller2];
keyP2Action1 = max(keyboard_check(global.keyP2Action1) &amp;&amp; global.keyP2Action1 != -1,gamepad_button_check(controller2,global.keyP2Action1));
keyP2Action1Pressed = max(keyboard_check_pressed(global.keyP2Action1) &amp;&amp; global.keyP2Action1 != -1,gamepad_button_check(controller2,global.keyP2Action1));
keyP2Action2 = max(keyboard_check(global.keyP2Action2) &amp;&amp; global.keyP2Action2 != -1,gamepad_button_check(controller2,global.keyP2Action2));
keyP2Action2Pressed = max(keyboard_check_pressed(global.keyP2Action2) &amp;&amp; global.keyP2Action2 != -1,gamepad_button_check(controller2,global.keyP2Action2));
keyP2Action3 = max(keyboard_check(global.keyP2Action3) &amp;&amp; global.keyP2Action3 != -1,gamepad_button_check(controller2,global.keyP2Action3));
keyP2Action3Pressed = max(keyboard_check_pressed(global.keyP2Action3) &amp;&amp; global.keyP2Action3 != -1,gamepad_button_check(controller2,global.keyP2Action3));
keyP2Pause = max(keyboard_check(global.keyP2Pause) &amp;&amp; global.keyP2Pause != -1,gamepad_button_check(controller2,global.keyP2Pause));
keyP2PausePressed = max(keyboard_check_pressed(global.keyP2Pause) &amp;&amp; global.keyP2Pause != -1,gamepad_button_check(controller2,global.keyP2Pause));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Detect controllers
show_debug_message("Event = " + async_load[? "event_type"]);        // Debug cocde so you can see which event has been
show_debug_message("Pad = " + string(async_load[? "pad_index"]));   // triggered and the pad associated with it.

switch(async_load[? "event_type"])             // Parse the async_load map to see which event has been triggered
{
    case "gamepad discovered":                     // A game pad has been discovered
        var pad = async_load[? "pad_index"];       // Get the pad index value from the async_load map
        if (p1HasController &lt;= 0)
        {
            p1HasController = pad;
        }
        else if (p2HasController &lt;= 0)
        {
            p2HasController = pad;
        }
        //gamepad_set_axis_deadzone(pad, 0.5);       // Set the "deadzone" for the axis
        //gamepad_set_button_threshold(pad, 0.1);    // Set the "threshold" for the triggers
        break;
    case "gamepad lost":                           // Gamepad has been removed or otherwise disabled
        var pad = async_load[? "pad_index"];       // Get the pad index
        if (p1HasController == pad)
        {
            p1HasController = 0;
        }
        else if (p2HasController == pad)
        {
            p2HasController = 0;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle item equip screen

if (global.state==states.equipScreen)
{
    //For optimization purposes.
    //You can read more about this here: http://www.yoyogames.com/blog/23
    draw_enable_alphablend(false);

    draw_set_color(c_black);
    draw_rectangle(0,0,512,288,false);
    draw_background(bkgWeaponSelect,128,20);
    draw_enable_alphablend(true);
    
    //Player 1
    if (equipChangeTimer%5==0)
    {
        equipTypeBlinkShow = !equipTypeBlinkShow;
        equipShieldBlinkShow = !equipShieldBlinkShow;
    }
    
    if (global.tick%90==0)
    {
        frModeFlicker = !frModeFlicker; //Friendly Mode text on Equip Screen
    }
    
    //Player 2
    if (p2EquipChangeTimer%5==0)
    {
        p2EquipTypeBlinkShow = !p2EquipTypeBlinkShow;
        p2EquipShieldBlinkShow = !p2EquipShieldBlinkShow;
    }
    
    if (global.tick%8==0)
    {
        glFlicker = !glFlicker; //Good Luck! Text on the Equip Screen
    }
    
    //All the code from here to the bottom draws the green, rectangular boxes on the Equip Type Mode screen
    draw_set_color($88E0A0);
    
    //Equip menu stuff
    if (typeSelect)
    {
        if (equipTypeBlinkShow || equipChangeTimer&lt;=0  || shieldSelect!=0)
        {
            draw_sprite(sprEquipHighlight,0,128+14,20+26+(equipTypePos*32));                           //Top-Left
            draw_sprite_ext(sprEquipHighlight,0,128+241,20+26+(equipTypePos*32),-1,1,0,c_white,1);     //Top-Right
            draw_sprite_ext(sprEquipHighlight,0,128+14,20+54+(equipTypePos*32),1,-1,0,c_white,1);      //Bottom-Left
            draw_sprite_ext(sprEquipHighlight,0,128+241,20+54+(equipTypePos*32),-1,-1,0,c_white,1);    //Bottom-Right
            
            draw_rectangle(128+16,24+(equipTypePos*32),128+238,24+(equipTypePos*32),false);     //Upper
            draw_rectangle(128+13,27+(equipTypePos*32),128+13,52+(equipTypePos*32),false);      //Left
            draw_rectangle(128+241,27+(equipTypePos*32),128+241,52+(equipTypePos*32),false);    //Right
            draw_rectangle(128+16,55+(equipTypePos*32),128+238,55+(equipTypePos*32),false);     //Lower
        }

        if (equipShieldBlinkShow || equipChangeTimer&lt;=0 || shieldSelect!=1)
        {
        draw_sprite(sprEquipHighlight,0,153+(equipShieldPos*48),188);                         //Top-Left
        draw_sprite_ext(sprEquipHighlight,0,183+(equipShieldPos*48),188,-1,1,0,c_white,1);    //Top-Right
        draw_sprite_ext(sprEquipHighlight,0,153+(equipShieldPos*48),214,1,-1,0,c_white,1);    //Bottom-Left
        draw_sprite_ext(sprEquipHighlight,0,183+(equipShieldPos*48),214,-1,-1,0,c_white,1);   //Bottom-Right
        
        draw_rectangle(155+(equipShieldPos*48),186,180+(equipShieldPos*48),186,false);     //Upper
        draw_rectangle(152+(equipShieldPos*48),190,152+(equipShieldPos*48),211,false);     //Left
        draw_rectangle(183+(equipShieldPos*48),190,183+(equipShieldPos*48),211,false);     //Right
        draw_rectangle(155+(equipShieldPos*48),215,180+(equipShieldPos*48),215,false);     //Lower
        }
        
        if (equipTypePos==p2EquipTypePos &amp;&amp; currPlayers&gt;1)
        {
            draw_set_color($88E0A0);   
        }
        else
        {draw_set_color(c_red);}
        
        if ((p2EquipTypeBlinkShow || p2EquipChangeTimer&lt;=0  || p2ShieldSelect!=0) &amp;&amp; objMain.currPlayers &gt;1)
        {
            draw_sprite(sprEquipHighlight,1,14,26+(p2EquipTypePos*32));                           //Top-Left
            draw_sprite_ext(sprEquipHighlight,1,241,26+(p2EquipTypePos*32),-1,1,0,c_white,1);     //Top-Right
            draw_sprite_ext(sprEquipHighlight,1,14,54+(p2EquipTypePos*32),1,-1,0,c_white,1);      //Bottom-Left
            draw_sprite_ext(sprEquipHighlight,1,241,54+(p2EquipTypePos*32),-1,-1,0,c_white,1);    //Bottom-Right
            
            if (equipTypePos!=p2EquipTypePos || ((equipChangeTimer&gt;0 &amp;&amp; !equipTypeBlinkShow) &amp;&amp; shieldSelect&lt;1))
            {
                draw_set_color(c_red);
            }
            else
            {draw_set_color($88E0A0);}
                draw_rectangle(16,24+(p2EquipTypePos*32),238,24+(p2EquipTypePos*32),false);     //Upper
                draw_rectangle(13,27+(p2EquipTypePos*32),13,52+(p2EquipTypePos*32),false);      //Left
                draw_rectangle(241,27+(p2EquipTypePos*32),241,52+(p2EquipTypePos*32),false);    //Right
                draw_rectangle(16,55+(p2EquipTypePos*32),238,55+(p2EquipTypePos*32),false);     //Lower
            
        }

        if (equipShieldPos==p2EquipShieldPos &amp;&amp; currPlayers&gt;1)
        {
            draw_set_color($88E0A0);   
        }
        else
        {draw_set_color(c_red);}
        
        if ((p2EquipShieldBlinkShow || p2EquipChangeTimer&lt;=0 || p2ShieldSelect!=1) &amp;&amp; objMain.currPlayers &gt;1)
        {
        draw_sprite(sprEquipHighlight,1,153+(p2EquipShieldPos*48),188);                         //Top-Left
        draw_sprite_ext(sprEquipHighlight,1,183+(p2EquipShieldPos*48),188,-1,1,0,c_white,1);    //Top-Right
        draw_sprite_ext(sprEquipHighlight,1,153+(p2EquipShieldPos*48),214,1,-1,0,c_white,1);    //Bottom-Left
        draw_sprite_ext(sprEquipHighlight,1,183+(p2EquipShieldPos*48),214,-1,-1,0,c_white,1);   //Bottom-Right
        if (equipShieldPos!=p2EquipShieldPos || ((equipChangeTimer&gt;0 &amp;&amp; !equipShieldBlinkShow) &amp;&amp; shieldSelect==1))
            {
                draw_set_color(c_red);
            }
            else
            {draw_set_color($88E0A0);}
        draw_rectangle(155+(p2EquipShieldPos*48),186,180+(p2EquipShieldPos*48),186,false);     //Upper
        draw_rectangle(152+(p2EquipShieldPos*48),190,152+(p2EquipShieldPos*48),211,false);     //Left
        draw_rectangle(183+(p2EquipShieldPos*48),190,183+(p2EquipShieldPos*48),211,false);     //Right
        draw_rectangle(155+(p2EquipShieldPos*48),215,180+(p2EquipShieldPos*48),215,false);     //Lower
        }
        
        if (global.frModeEnabled &amp;&amp; frModeFlicker)
        {
            draw_set_color(c_yellow);
            draw_text(0,8*29,"Friendly Mode: Auto-Force Field");
        }
    }
    draw_set_color($88E0A0);
    if (shieldSelect&gt;1)
    {draw_text(0,8*28,"PLAYER 1 READY");}
    
    draw_set_color(c_red);
    if ((p2ShieldSelect&gt;1) &amp;&amp; objMain.currPlayers &gt;1)
    {draw_text(8*16,8*28,"PLAYER 2 READY");}
      
    if (glTimer&gt;0)
    {
        draw_set_color(c_black);
        draw_rectangle(0,8*13,300,8*16,false);
        if (glFlicker)
        {
            draw_set_color(c_white);
            draw_text((8*11)+4,8*14,"Good luck!");
        }
        glTimer--;
    }    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle game closing (if objCamera doesn't exist yet)
draw_enable_alphablend(false);

if !instance_exists(objCamera)
{
    draw_set_alpha(1);
    if (gameEndTimer&lt;40 &amp;&amp; gameEndTimer&gt;=30)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game");
    }
    else if (gameEndTimer&lt;30 &amp;&amp; gameEndTimer&gt;=20)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game.");
    }
    else if (gameEndTimer&lt;20 &amp;&amp; gameEndTimer&gt;=10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game..");
    }
    else if (gameEndTimer&lt;10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game...");
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle game bootup text and set a global (sprite-based) font
draw_enable_alphablend(false);

if global.tick==5||global.tick==6 {
    draw_set_color(c_white);
    draw_rectangle(-8,128,290,140,false);
}
else if global.tick==8||global.tick==9
{
    draw_set_color(c_gray);
    draw_rectangle(-8,40,290,42,false);
}

draw_set_font(global.font);

attributionOffsetX = 175
attributionOffsetY = 100

if global.tick&lt;=waitTime+10
{
    draw_set_color(c_white);
    draw_set_alpha(1);
    draw_text(attributionOffsetX,attributionOffsetY,"    Gradius Engine#     v1.5 Preview##     original by##     mysterypaint##     modified by #      slowbeef");
}

//Fade out on top of the text
draw_enable_alphablend(true);
draw_set_color(c_black);

if global.tick&lt;=15 || (global.tick &gt;waitTime+5 &amp;&amp; global.tick &lt;=waitTime+10)
{
    draw_set_alpha(0.8);
    draw_rectangle(-1,16,257,257,false);
}
else if (global.tick&gt;15 &amp;&amp; global.tick&lt;=20) || (global.tick&gt;waitTime &amp;&amp; global.tick&lt;=waitTime+5)
{
    draw_set_alpha(0.4);
    draw_rectangle(-1,16,257,257,false);
}
else if global.tick&gt;20 &amp;&amp; global.tick&lt;=waitTime
{
    draw_set_alpha(0);
    draw_rectangle(-1,16,257,257,false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
