<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize some variables
depth=1000000;

debug=false;
camMoveSpeed=4;
tilemapViewportWidth=global.width;
tilemapViewportHeight=global.height;
//Always leave these at 0
scrollX=0.3;
scrollY=0;
prevScrollX = 0.3;
prevScrollY = 0;

//Reserved for recalling the previous scroll rate upon pausing/cutscene triggers
scrollXPrevious=0;
scrollYPrevious=0;
pauseFlickerOn = false;
//Reserved for drawing "START" on the screen in objCamera's draw event
startFlickerOn=false;
startWaitTimer=0;

//Screen borders
leftBound=16;
rightBound=16;
upperBound=28;
lowerBound=32;
viewportWidth=global.width;
viewportHeight=global.height;

//Cutscene bars
yCutsceneBarTo=0;
yCutsceneBarPos=-32;

//Force background to where this camera is
background_x[0] = objCamera.x+objMain.bg0XParallax;
background_x[1] = objCamera.x+objMain.bg1XParallax;
background_x[2] = objCamera.x+objMain.bg2XParallax;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move the camera after everything else has moved
if (global.state!=states.startRoom)
{
    x += scrollX * objMain.deltaTime;
    y += scrollY * objMain.deltaTime;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug moving camera
//Uses WASD but UDLR if WASD is occupied

var movingVert;
var movingHoriz;

//Toggle debug mode with Q. Go to objMain's Create Event to disable this for public builds.
if (objMain.debugEnabled)
{
    if (keyboard_check_pressed(ord('Q')))
    {
    debug = !debug;
    }
}

//Debug Mode code (There's even more in objCamera's Draw Event "Debug Mode" script
if (debug)
{

    //Export level debug code
    if keyboard_check_pressed(ord('P')){exportLevel()};
    
    //Sets camera scroll to 0.3
    if (keyboard_check_pressed(ord('R')))
    {
    scrollX = 0.3;
    }
    
    //Increment/decrement player lives
    if (keyboard_check_pressed(vk_add))
            {
            global.playerLives++;
            }
    if (keyboard_check_pressed(vk_subtract))
            {
            global.playerLives--;
            }
    
    //Debug camera movement input checking
    if (keyboard_check(global.cameraUp) &amp;&amp; global.cameraUp != global.keyUp) || (keyboard_check(vk_up) &amp;&amp; global.cameraUp == global.keyUp)
    {
    movingVert=1;
    }
    else if (keyboard_check(global.cameraDown) &amp;&amp; global.cameraDown != global.keyDown) || (keyboard_check(vk_down) &amp;&amp; global.cameraDown == global.keyDown)
    {
    movingVert=2;
    }
    else
    {
    movingVert=0;
    }

    if (keyboard_check(global.cameraLeft) &amp;&amp; global.cameraLeft != global.keyLeft) || (keyboard_check(vk_left) &amp;&amp; global.cameraLeft == global.keyLeft)
    {
    movingHoriz=1;
    }
    else if (keyboard_check(global.cameraRight) &amp;&amp; global.cameraRight != global.keyRight) || (keyboard_check(vk_right) &amp;&amp; global.cameraRight == global.keyRight)
    {
        movingHoriz=2;
    }
    else
    {
        movingHoriz=0;
    }
    
    //Based on the camera movement input, move the camera itself by camMoveSpeed (Defined in objCamera's Create Event)
    if (objMain.currPlayers&lt;=1)
    {
        switch(movingVert)
        {
        case 1: y-=camMoveSpeed;break; //up
        case 2: y+=camMoveSpeed;break; //down
        default: break;
        }
        
        switch(movingHoriz)
        {
        case 1: x-=camMoveSpeed;break; //left
        case 2: x+=camMoveSpeed;break; //right
        default: break;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move the view and sky background

//Every frame, we should check for any level events (bgm changing, map switching, etc)
levelEvents();

//We should also have the background follow the camera.
background_x[0] = objCamera.x+objMain.bg0XParallax;
background_x[1] = objCamera.x+objMain.bg1XParallax;
background_x[2] = objCamera.x+objMain.bg2XParallax;



view_xview = x + scrollX * objMain.deltaTime;
view_yview = y + scrollY * objMain.deltaTime;

objMain.bg0XParallax+=background_hspeed[0];
objMain.bg1XParallax+=background_hspeed[1];
objMain.bg2XParallax+=background_hspeed[2];

background_x[0] = x+objMain.bg0XParallax;
background_x[1] = x+objMain.bg1XParallax;
background_x[2] = x+objMain.bg2XParallax;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw sprites under layer 1
//This is the bottom-most layer to draw onto the screen

//For optimization purposes.
//You can read more about this here: http://www.yoyogames.com/blog/23
draw_enable_alphablend(true);

/*
if (global.state != states.startRoom)
{
}
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing layer 1

if (global.state==2 || global.state==3 || global.state==5) {
    if (ds_exists(objMain.levelData,ds_type_grid)) {    
    
    //dynamic render
    var startCol = floor(objCamera.x / global.tileWidth)-1;
    var endCol = startCol + (objCamera.tilemapViewportWidth / global.tileWidth);
    var startRow = floor(objCamera.y / global.tileHeight)-1;
    var endRow = startRow + (objCamera.tilemapViewportHeight / global.tileWidth);
    
    var offsetX = startCol * global.tileWidth;
    var offsetY = startRow * global.tileHeight;
    
    
    for (var c = startCol; c &lt;= endCol; c++)
    {
        for (var r = startRow; r &lt;= endRow; r++)
        {
            
            if (c&gt;=0 &amp;&amp; c&lt;(global.mapWidth) &amp;&amp; r&gt;=0 &amp;&amp; r&lt;(global.mapHeight))
            {
                var tileID = real(ds_grid_get(objMain.levelDataLayer2, c, r));
                if (tileID &lt;= 0)
                {
                    tileID = real(ds_grid_get(objMain.levelData, c, r));
                }
            }
            else {tileID=0;}
            
//            if (tileID&lt;0)
//
            var xPos = round((c - startCol) * global.tileWidth + offsetX);
            var yPos = round((r - startRow) * global.tileHeight + offsetY);
    
            if (tileID &gt; 0)
            {
                
                draw_background_part(
                    global.tilesetIndex, // image
                    getTile(real(tileID),3), // source x
                
                    getTile(real(tileID),4), // source y
                    global.tileWidth, // source width
                    global.tileHeight, // source height
                    xPos,// target x
                    yPos // target y
                    );//depth
                
            }
        }
    }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw sprites under player

if (global.state != states.startRoom)
{
    drawSprites(objBossLaser,sprBossLaser);
    drawSprites(objBoss1,sprBoss1);
    drawSprites(objBossEye,sprBossEye);
    drawSprites(objBossBarrier,sprBossBarrier);
    drawSprites(obj16x16Explosion,spr16x16Explosion);
    drawSprites(objCapsule,sprCapsule);
    drawSprites(objChunkExplosion,sprChunkExplosion);
    
    //Draw missiles
    if instance_exists(objMissile)
    {
        var i;
        for (i = 0; i &lt; instance_number(objMissile); i += 1)
        {
            thisMissile = instance_find(objMissile,i);
            with (thisMissile)
            {
                draw_sprite_ext(sprMissile,image_index,x,y+yOffset,image_xscale,image_yscale,0,c_white,1); //offset the y position of our drawing if the missile has landed on the ground.
            }
        }
    }
    
    drawSprites(objBullet,sprBullet);
    
    for(var i=0; i&lt;instance_number(objDouble);i++)
    {
        thisDouble = instance_find(objDouble,i);
        if (thisDouble.doubleType==1 || thisDouble.doubleType==3 || thisDouble.doubleType==4)
        {
            draw_sprite_ext(sprDouble,thisDouble.image_index,thisDouble.x,thisDouble.y,thisDouble.image_xscale,thisDouble.image_yscale,0,c_white,1);
        }
        else if (thisDouble.doubleType==2)
        {
            draw_sprite_ext(sprBullet,thisDouble.image_index,thisDouble.x,thisDouble.y,thisDouble.image_xscale,thisDouble.image_yscale,0,c_white,1);
        }
    }

    drawLaser();
    
    //Loop through every single instance of the Option and draw them one by one
    if instance_exists(objOption)
        {
            var i;
            for (i = 0; i &lt; instance_number(objOption); i += 1)
               {
                thisOption = instance_find(objOption,i);
                with (thisOption)
                    {
                    if (enabled)
                        {
                        draw_sprite(sprOption,image_index,x,y);
                        }
                    }
    
               }
        }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the player


if global.state!=4
{


    if (instance_exists(objPlayer2))
    {
        if (global.tick%objPlayer2.invBlinkRate==0)
        {
            if (objMain.deltaTime&gt;0)
            {
                objPlayer2.playerVisible = !objPlayer2.playerVisible
            }
        }
        if (!objPlayer2.dead)
        {
            if (objPlayer2.invincibilityFrames&lt;=0 || objPlayer2.playerVisible || objPlayer2.flyingIn&lt;0)
            {
                draw_sprite(sprPlayer2,objPlayer2.image_index,objPlayer2.x+objPlayer2.flyingIn,objPlayer2.y-1);
                draw_sprite(sprPlayerFlame2,objPlayer2.flameImgInd,objPlayer2.x-16+objPlayer2.flyingIn,objPlayer2.y);
            }
        }
        else
        {
            with(objPlayer2)
                {
                if (deadTimer&gt;4*deadTimerMult+deadWaitTime){image_index=4;}
                if (deadTimer&gt;3*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=4*deadTimerMult+deadWaitTime){image_index=3;}
                if (deadTimer&gt;2*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=3*deadTimerMult+deadWaitTime){image_index=2;}
                if (deadTimer&gt;1*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=2*deadTimerMult+deadWaitTime){image_index=1;}
                if (deadTimer&gt;deadWaitTime &amp;&amp; deadTimer&lt;=1*deadTimerMult+deadWaitTime){image_index=0;}
                }
                
                if (objPlayer2.deadTimer&gt;objPlayer2.deadWaitTime)
                {
                    draw_sprite(sprPlayerExplode,objPlayer2.image_index,objPlayer2.x,objPlayer2.y-1);
                }
        }
        
        if (objCamera.debug)
            {
            draw_set_alpha(0.4);
            draw_sprite(sprPlayerCapsuleHitbox,0,objPlayer2.x,objPlayer2.y);
            draw_set_alpha(0.7);
            draw_sprite(sprPlayerHitbox,0,objPlayer2.x,objPlayer2.y);
            draw_set_alpha(1);
            }
        }
        
    if (instance_exists(objPlayer1))
    {
        if (!objPlayer1.dead)
        {
            if (global.tick%objPlayer1.invBlinkRate==0)
            {
                if (objMain.deltaTime&gt;0)
                {
                    objPlayer1.playerVisible = !objPlayer1.playerVisible;
                }
            }
            
            if (!objPlayer1.dead)
            {
                if (objPlayer1.invincibilityFrames&lt;=0 || objPlayer1.playerVisible || objPlayer1.flyingIn&lt;0)
                {
                    draw_sprite(sprPlayer,objPlayer1.image_index,objPlayer1.x+objPlayer1.flyingIn,objPlayer1.y-1);
                    draw_sprite(sprPlayerFlame,objPlayer1.flameImgInd,objPlayer1.x-16+objPlayer1.flyingIn,objPlayer1.y);
                }
            }
        }
        else
        {
            with(objPlayer1)
                {
                if (deadTimer&gt;4*deadTimerMult+deadWaitTime){image_index=4;}
                if (deadTimer&gt;3*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=4*deadTimerMult+deadWaitTime){image_index=3;}
                if (deadTimer&gt;2*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=3*deadTimerMult+deadWaitTime){image_index=2;}
                if (deadTimer&gt;1*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=2*deadTimerMult+deadWaitTime){image_index=1;}
                if (deadTimer&gt;deadWaitTime &amp;&amp; deadTimer&lt;=1*deadTimerMult+deadWaitTime){image_index=0;}
                }
                
                if (objPlayer1.deadTimer&gt;objPlayer1.deadWaitTime)
                {
                    draw_sprite(sprPlayerExplode,objPlayer1.image_index,objPlayer1.x,objPlayer1.y-1);
                }
        }
        
        if (objCamera.debug)
            {
            draw_set_alpha(0.4);
            draw_sprite(sprPlayerCapsuleHitbox,0,objPlayer1.x,objPlayer1.y);
            draw_set_alpha(0.7);
            draw_sprite(sprPlayerHitbox,0,objPlayer1.x,objPlayer1.y);
            draw_set_alpha(1);
            }
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw sprites over player
//Draw front shields
if (global.state != states.startRoom)
{
    //Drawing the standard shield
    if instance_exists(objFrontShield)
        {
            var i;
            for (i = 0; i &lt; instance_number(objFrontShield); i += 1)
               {
                thisObject = instance_find(objFrontShield,i);
                with (thisObject)
                    {
                    draw_sprite_ext(sprFrontShield,image_index,x,y,image_xscale, image_yscale,0,c_white,1);
                    }
    
               }
        }
    
        
    //Drawing the Force Field
    drawForceField(objPlayer1);
    if instance_exists(objPlayer2)
    {
        drawForceField(objPlayer2);
    }
    
    drawSprites(objEnemyBullet,sprEnemyBullet);
    drawSprites(objDee01,sprDee01);
    drawSprites(objLion,sprLion);
    drawSprites(objBean,sprBean);
    drawSprites(objSpreadExplosion,sprSpreadExplosion);
    drawSprites(objBigExplosion,sprBigExplosion);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// This is no longer needed, but uncomment it if you get a third layer meant to go over the ship.

/*
///Drawing overlay layer

if (global.state==2 || global.state==3 || global.state==5) {
    if (ds_exists(objMain.levelDataLayer2,ds_type_grid)) {
    
    //dynamic render
    var startCol = floor(objCamera.x / global.tileWidth)-1;
    var endCol = startCol + (objCamera.tilemapViewportWidth / global.tileWidth);
    var startRow = floor(objCamera.y / global.tileHeight)-1;
    var endRow = startRow + (objCamera.tilemapViewportHeight / global.tileWidth);
    
    var offsetX = startCol * global.tileWidth;
    var offsetY = startRow * global.tileHeight;
    
    
    for (var c = startCol; c &lt;= endCol; c++)
    {
        for (var r = startRow; r &lt;= endRow; r++)
        {
            
            if (c&gt;=0 &amp;&amp; c&lt;(global.mapWidth) &amp;&amp; r&gt;=0 &amp;&amp; r&lt;(global.mapHeight))
            {
                var tileID = real(ds_grid_get(objMain.levelDataLayer2, c, r));
                if (tileID &lt;= 0) 
                {
                    tileID = real(ds_grid_get(objMain.levelData, c, r));
                }
            }
            else {tileID=0;}
            
//            if (tileID &lt; 0)
//                {tileID = 0;}    
                var xPos = round((c - startCol) * global.tileWidth + offsetX);
                var yPos = round((r - startRow) * global.tileHeight + offsetY);
    
            if (tileID &gt; 0) // Change this back to !=0 to fix the foreground (?!)
            {
            
                draw_background_part(
                global.tilesetIndex, // image
                getTile(real(tileID),3), // source x
                
                getTile(real(tileID),4), // source y
                global.tileWidth, // source width
                global.tileHeight, // source height
                xPos,// target x
                yPos // target y
                );//depth

            }
        }
    }
    
    }

}
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle the START before the player gains control and pause text

if (global.tick%17==2 &amp;&amp; startWaitTimer&lt;=0)
    {startFlickerOn=!startFlickerOn; startWaitTimer=5;}
if startWaitTimer&gt;0{startWaitTimer--;}

if (global.state==states.startRoom)
{
    draw_set_color(c_black);
    draw_rectangle(objMain.x-16,objMain.y-16,objMain.x+viewportWidth+16,objMain.y+viewportHeight+16,false);
    
    if (startFlickerOn)
    {
        draw_sprite(sprStart,0,objMain.x+(viewportWidth/2),objMain.y+(viewportHeight/2)-8); //Arcade Style
    }
}

if (global.tick%40==2)
    {pauseFlickerOn=!pauseFlickerOn;}


if (global.state==states.paused)
{
    draw_enable_alphablend(true);
    draw_set_color(c_white);
    
    if (pauseFlickerOn)
    {
        draw_text(x+(viewportWidth/2)-(8*3),y+(viewportHeight/2)-(8*2),"PAUSED"); //SNES Style
    }
}

if (global.state==states.gameMode &amp;&amp; objMain.showLoop&gt;0)
{
    draw_enable_alphablend(true);
    draw_set_color(c_white);
    
    
    draw_text(x,y+(viewportHeight/2)-(8*3),"    Congratulations! Now try");
    if (pauseFlickerOn)
    {
        draw_text(x+(viewportWidth/2)-(8*3),y+(viewportHeight/2)-(8*2),"Loop " + string(objMain.loopCounter) + "!");
    }
    
    objMain.showLoop--;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the Powerup HUD
draw_enable_alphablend(false);
if (global.state==states.gameMode ||
    global.state==states.cutscene ||
    global.state==states.startRoom ||
    global.state==states.paused)
{
    if (objMain.currPlayers&lt;=1)
    {
        singlePlayerPowerupHUD();
    }
    else
    {
        multiPlayerPowerupHUD();
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the upper HUD
draw_enable_alphablend(true);
draw_set_color(c_white);

var playersText = "1P";
if (objMain.currPlayers&gt;1) {playersText = "CO";}

//Calculate the spacing between "P1" and the score location
var dynamicPlayerScoreSpacing="";
var lenPlayerScore = string_length(string(global.playerScore));
for(var i=0; i&lt;13-lenPlayerScore;i++)
{
    dynamicPlayerScoreSpacing+=" ";
}

//Calculate the spacing between "HI" and the score location
var dynamicHighScoreSpacing="";
var lenHighScore = string_length(string(global.highScore));
for(var i=0; i&lt;13-lenHighScore;i++)
{
    dynamicHighScoreSpacing+=" ";
}

//Finally, draw the score onto the screen

draw_text(objCamera.x, objCamera.y+4, playersText + dynamicPlayerScoreSpacing + string(global.playerScore));
if (objMain.currPlayers&lt;=1)
{
    draw_text(objCamera.x+(8*16), objCamera.y+4, "HI" + dynamicHighScoreSpacing + string(global.highScore));
}
else
{
    draw_text(objCamera.x+(8*16), objCamera.y+4, "HI" + dynamicHighScoreSpacing + string(global.highCoScore));
}

//Next, draw the lives
var livesDispNum = global.playerLives; //The number of lives to show on the screen
var livesText = "";

if (global.playerLives&gt;9)
{
//We only want to draw 9 on the screen at a time (the last life isn't displayed), so use modulo (%) to display the remainder of lives after division
livesDispNum = global.playerLives%10;
}

//After we found out how many lives we're supposed to draw on the screen, do so using ~ in sprFont to represent each life

for (var i=0; i&lt;livesDispNum;i++)
{
    livesText+="~";
}

//By the way, 0 is the last life before a game over, not 1.
draw_text(objCamera.x,objCamera.y+4,"# " + livesText);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Cutscene borders
draw_enable_alphablend(false);
var cutsceneBarMoveSpeed=4;

if global.state==2
{
    yCutsceneBarTo=-32;
    if yCutsceneBarPos&gt;yCutsceneBarTo
    {
        yCutsceneBarPos-=cutsceneBarMoveSpeed;
    }
}
else if global.state==3
{
    yCutsceneBarTo=0;
    if yCutsceneBarPos&lt;yCutsceneBarTo
    {
        yCutsceneBarPos+=cutsceneBarMoveSpeed;
    }
    else
    {
        //the cutscene is completely gone. restore the previous game state here
        
    }
    
}

draw_set_color(c_black);

//upper
draw_rectangle(x-8,y+yCutsceneBarPos-1,x+263,y+yCutsceneBarPos+31,false);
//lower
draw_rectangle(x-8,y+224-yCutsceneBarPos,x+263,y+223-yCutsceneBarPos+32,false);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle screen flashing
if (objPlayer.excTimer&gt;0)
{
    if (global.tick%2==0)
    {
        draw_enable_alphablend(false);
        draw_set_color(c_white);
        draw_rectangle(x-64,y-64,x+viewportWidth+64,y+viewportHeight+64,false);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug stuff
draw_enable_alphablend(true);

if (debug)
{
    
    var posX=floor(mouse_x/16);
    var posY=floor(mouse_y/16);
    var changeTile=false;

    draw_set_color(c_white);
    if (posX&lt;=global.mapWidth-1 &amp;&amp; posX&gt;=0) &amp;&amp; (posY&lt;=global.mapHeight-1 &amp;&amp; posY&gt;=0)
    {
    var tile = real(ds_grid_get(objMain.levelData,posX,posY));
    if tile&lt;0 {tile=0;}
    
    draw_text(objCamera.x,objCamera.y+4,"###Mouse on tile type: " + string(tile) + "(" + string(objMain.tiletypes[tile]) + ")");
    
    //Allow debug changing tile if you left/right-click over the tile. Cycle through the tiles.
    if mouse_check_button_pressed(mb_left) &amp;&amp; !mouse_check_button_pressed(mb_right){if tile&lt;255{tile++;}else{tile=0;} changeTile=true;}
    if mouse_check_button_pressed(mb_right) &amp;&amp; !mouse_check_button_pressed(mb_left){if tile&gt;0{tile--;}else{tile=255;} changeTile=true;}
    if keyboard_check(vk_shift) &amp;&amp; mouse_check_button(mb_right){tile=0;}
    if (changeTile){ds_grid_set(objMain.levelData,posX,posY,tile);}
    
    draw_set_color(c_green);
    }
    else{draw_text(objCamera.x,objCamera.y+4,"###Mouse on tile type: OoB");draw_set_color(c_red);}
    draw_set_alpha(0.3);
    draw_rectangle(posX*16,posY*16,posX*16+15,posY*16+15,false);
    draw_set_alpha(1);
    
    draw_set_color(c_white);
    
    draw_text(objCamera.x,objCamera.y+12+16,"#P1: " + string(objPlayer1.numOfOpts));
    if instance_exists(objPlayer2)
    {
        draw_text(objCamera.x,objCamera.y+12+16+8,"#P2: " + string(objPlayer2.numOfOpts));
    }
    for (var i=0; i&lt;instance_number(objOption); i++)
    {
        var thisOption = instance_find(objOption,i);
        draw_text(objCamera.x,objCamera.y+32+20+(i*8),"Opt " + string(i) + ": " + string(thisOption.myID));
    }
    
    //draw_text(objCamera.x,objCamera.y+4,"#####FPS: " + string(fps)
    //+ "#Total entities: " + string(instance_count)
    //+ "#Game Loop: " + string(objMain.loopCounter));
    
    if global.state == 2
    {
        if keyboard_check_pressed(ord('E'))
        {
        global.state = 3;
        }
    }
    else if global.state == 3
    {
        if keyboard_check_pressed(ord('E'))
            {
            global.state = 2;
            }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle game closing text
draw_enable_alphablend(false);

    if (objMain.gameEndTimer&lt;40 &amp;&amp; objMain.gameEndTimer&gt;=30)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game");
    }
    else if (objMain.gameEndTimer&lt;30 &amp;&amp; objMain.gameEndTimer&gt;=20)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game.");
    }
    else if (objMain.gameEndTimer&lt;20 &amp;&amp; objMain.gameEndTimer&gt;=10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game..");
    }
    else if (objMain.gameEndTimer&lt;10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game...");
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
